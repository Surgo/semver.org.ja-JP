---
layout: default
title: セマンティックバージョニング
---

セマンティックバージョニング
============================

ソフトウェア管理の世界には、
["依存性地獄 (DLL地獄)"](http://ja.wikipedia.org/wiki/DLL%E5%9C%B0%E7%8D%84 "DLL地獄 - Wikipedia")
と呼ばれている恐ろしい場所が存在する。
システムが大きくなればなるほど、
またソフトウェアにより多くのパッケージを統合していくほど、
ある日突然この絶望の縁に立っていることに気がつくことになります。


依存が多いシステムでの新しいパッケージバージョンのリリースは、直ちに悪夢へ変わるでしょう。
依存仕様を厳しくした場合は、バージョンロック
(すべての依存パッケージ毎に新しいバージョンをリリースしなければパッケージのアップグレードができない)
の危険があります。
依存仕様を緩くした場合は、必然的にバージョンの混乱
(適切なバージョンではなく、将来のバージョンと互換性まで仮定してしまう)
を招くことになります。
バージョンロックやバージョンの混乱により、
プロジェクトを簡単に、また安全に移動できなくなるのが依存性地獄です。

この問題の解決として、
どのバージョン番号を割り当て、加算するかを決定するための簡潔なルールセットと必要条件を提案します。
この仕組が動作するためには、パブリック API を宣言する必要があります。
これは単にドキュメントかもしれませんし、実行するコードそのものかもしれません。
とにもかくにも、この API は明確で正確であることが重要です。
一旦パブリック API を宣言したら、特定のバージョン番号までの加算履歴を明記します。
バージョンのフォーマットは X.Y.Z (メジャー.マイナー.パッチ) を検討してください。
API に影響を及ぼさないバグフィックスはパッチのバージョンを加算し、
古い API と互換性を持つ API の追加や変更はマイナーのバージョンを加算し、
後方非互換の API の変更はメジャーのバージョンを加算します。

これを "セマンティックバージョニング" システムと呼びます。
このスキームの下では、
バージョン番号とその変化は、
配下の特定バージョンのコードと次のバージョンのコード間の修正を意味付けします。
バージョン番号の割り当てとその加算方法の明示は必須です。

セマンティックバージョニングの仕様 (SemVer)
-------------------------------------------

ドキュメント内のキーワード
"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL"
は [RFC2119](http://www.ietf.org/rfc/rfc2119.txt "RFC2119")
([日本語訳](http://www.ipa.go.jp/security/rfc/RFC2119JA.html "RFC2119JA"))
に記載されてる通り解釈する。

1. セマンティックバージョニングを用いるソフトウェアは、パブリック API を宣言しなければならない (MUST)。
この API はコードそのもので宣言するか、もしくはドキュメント内に厳密に指定する。
いかなる場合においても、それは正確で包括的である必要がある。

1. 通常バージョン番号は X.Y.Z 形式で、 X, Y, Z は数値にしなければならない (MUST)。
X はメジャーバージョン、Y はマイナーバージョン、Z はパッチバージョンとする。
各要素は、数的に加算しなければならない (MUST)。
例えば: 1.9.0 < 1.10.0 < 1.11.0 など。

1. パッチバージョンに続いて任意の文字列を追加することにより、特別なバージョン番号を明記してもよい (MAY)。
この文字列は英文字で開始しなければならず (MUST)、英数字と横線 (-) で形成しなければならない (MUST)。
特別なバージョン番号は、関連するバージョンよりも優先順位が低くなる。
優先順位は ASCII コード順にソートする必要がある (SHOULD)。
例えば:  1.0.0beta1 < 1.0.0beta2 < 1.0.0 など。

1. 一度パッケージのバージョンをリリースしたら、そのバージョンの内容は修正してはならない (MUST)。

1. メジャーバージョンのゼロ (0.y.z) は初期開発用とする。
すべてがいつでも変更される可能性がある。
パブリック API を安定 (stable) 版と判断されてはならない。

1. バージョン 1.0.0 はパブリック API を定義する。
バージョン番号の加算方法はこのパブリック API とその更新方法に依存する。

1. パッチバージョン Z (x.y.Z | x > 0) は、後方互換性を持つバグフィックスを適用した場合に加算しなければならない (MUST)。
バグフィックスとは不正な動作を修正するための内部変更と定義する。

1. マイナーバージョン Y (x.Y.z | x > 0) は、後方互換性を保ちつつ、新たにパブリック API を追加した場合に加算しなければならない (MUST)。
プライベートコードに新たな機能が追加したり、改修する場合もマイナーバージョンを加算することもできる (MAY)。
またパッチレベルの変更を含めてもよい (MAY)。

1. メジャーバージョン X (X.y.z | X > 0) は、パブリック API に後方互換性がない変更を加えた場合に加算しなければならない (MUST)。
マイナーレベル、パッチレベルの変更を含めてもよい (MAY)。

タグの仕様 (SemVerTag)
----------------------

バージョンコントロールシステム (Git, Mercurial, SVN 等) を利用する場合は、
この関連仕様を利用する必要がある (SHOULD)。
このシステムを利用することにより、
パッケージ検査の自動化、
およびセマンティックバージョニングの適用とリリースするバージョンの決定をする。

1. バージョンコントロールシステムでリリースにタグ付けする際、バージョンのタグはリリースする際は、
"v3.1.0" のように "vX.Y.Z" 形式にしなければならない (MUST)。

1. セマンティックバージョニングを導入する最初のタグは "semver" とする必要がある (SHOULD)。
これは既存のプロジェクトに対し、
任意の時点で適用し、
自動化ツールにより発見させるためである。

なぜセマンティックバージョニングを利用するのか?
-----------------------------------------------

これは新しい革新的考え方ではありません。
実際、おそらくこれに近い何かを実施しているでしょう。
問題は "まとめ" (標準化) が不十分ということです。
バージョン番号は正式な仕様書に定めない限り、基本的に依存管理に対してなんの役にも立ちません。
上記の考え方に名前と明確な定義をすることにより、ソフトウェアの意図をユーザに通知することが簡単になります。
一度この意図を明確にすると、最終的に柔軟な (しかし、そこまで柔軟ではない) 依存使用を作成することができます。

セマンティックバージョニングがどのように依存性地獄から開放するか、簡単な例を示します。
"Firetruck" (消防車) というライブラリがあったとします。
それがセマンティックバージョニングに適用したパッケージ "Ladder" (はしご) を必要とします。
Firetruck が作られた時点での Ladder パッケージのバージョンは 3.1.0 でした。
Firetruck は 3.1.0 で最初に導入されたいくつかの関数を用いているため、
Ladder への依存に対し問題なくバージョン 3.1.0 から 4.0.0 までを指定することができます。
現在 Ladder のバージョン 3.1.1 と 3.2.0 が利用できるのであれば、
パッケージ管理システムにそれをリリースでき、
それが既存のソフトウェアと後方互換性を持っていることを把握することができます。

信頼できる開発者ばかりで、
すべてのパッケージにおける関数のアップグレードを表記通りであると保証したいでしょう。
しかし現実の世界は泥臭いです。
それについては何も口出しできませんが、信頼される開発者としては注意が必要です。
セマンティックバージョニングを導入することにより、
依存するパッケージの新バージョンによる
パッケージのリリースと更新にかかる時間と面倒を省くことができます。
これが心地よく聞こえるなら、是非セマンティックバージョニングを利用し、
その原則に従うと断言してください。
この考え方を広め、多くの人が利益を得ることができるように、
README ファイルにこのウェブサイト (本家ページ 'http://semver.org/') へのリンクを記載してください。

FAQ
---

### いつ 1.0.0 をリリースするべきですか?

ソフトウェアがプロダクトとして利用されていば、それはすでに 1.0.0 でなければならないでしょう。
ユーザが安定 (stable) した API として利用している場合も 1.0.0 にするべきです。
後方互換について心配している場合も、おそらく 1.0.0 であるべきでしょう。

### これは高速開発と高速サイクルを妨げませんか?

メジャーバージョン 0 が高速開発のためにあります。
毎日のように API を変更しているのであれば、バージョン 0.x.x であるか、
もしくは主要バージョンからブランチを切り、別物として開発しなければなりません。

### パブリック API へのほんの小さな後方非互換の変更でもメジャーバージョンアップが必要とした場合、すぐ 42.0.0 まで到達してしまいませんか?

これは開発と発展に関する重要な質問です。
多くの依存コードがあるソフトウェアに対し、簡単に非互換の変更はしてはいけません。
更新に要するコストは重要です。
変更の影響をよく検討し、
そのコストともたらされる利点を天秤にかけ、
メジャーバージョンアップしなければなりません。

### すべてのパブリック API をドキュメント化する作業量は膨大です!

他のユーザから使用されることを目的とするソフトウェアを文書化するのは、プロの開発者としての責任です。
誰がどのようにソフトウェアを利用するべきか、
またどのように安全に呼び出すかは複雑であり、
このようなソフトウェア管理の複雑さは、
プロジェクトを効率的に運用する重要なポイントです。
長い目で見ると、
セマンティックバージョニングとパブリック API の定義により円滑に運用し続けることができます。

### 後方非互換の変更をマイナーバージョンとしてリリースしてしまった場合どうすれば良いですか?

セマンティックバージョニングの仕様にある通り、
すぐに問題を修正し、
後方互換性がある新しいマイナーバージョンをリリースしてください。
このような状況においてでも、バージョンのリリースを修正するのは受け入れがたいということを覚えておいてください。
適切な場合は、ユーザが問題のあるバージョンに気付けるよう、問題のあるバージョンを文書化し、ユーザに通知してください。

### 内部の依存関係のみを更新し、公開 API は変更しない場合はどうしますか?

それが公開 API に影響を及ぼさない場合は後方互換があると言えます。
開発者が気がつくように、パッケージの依存関係にそのパッケージが依存しているソフトウェアの依存仕様も必要です。
変更がパッチレベルか、マイナーレベルかを決定するのは、
バグの修正、もしくは新しい機能を追加するために内部の依存関係を更新したかどうか次第です。
内部の依存関係を更新した場合は、マイナーレベルの更新となります。

このドキュメントについて
------------------------

セマンティックバージョニング仕様はGravatars の創設者であり GitHub の共同創設者である
[Tom Preston-Werner](http://tom.preston-werner.com) によって書かれています。

もし、フィードバックしたい場合は [GitHub](https://github.com/mojombo/semver.org/issues "New Issue") に issue を登録してください。

日本語訳に関するフィードバックは、どうように [GitHub](https://github.com/Surgo/semver.org.ja-JP/issues/new "New Issue") に issue を登録してください。
